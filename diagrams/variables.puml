'''''''''
' Class '
'''''''''

class "StructVar" as STRUCT_VAR {
    value: float
    isConstant: bool
}

class "Automaton" as CLASS_AUTOMATE {
    - dicoVariables: map<SymbolVariable*, StructVar>
    - activeSymbol: IActiveSymbol
    + analyse()
    - lireSymbolSuivant()
    + execute()
}

abstract class "State" as CLASS_ETAT {
    - name: String
    + {abstract} transition(automate:Automate, symbol:Symbol)
}

'' Symbols ------------------------------------------------

abstract class "Symbol" as CLASS_SYMBOLE {
    # id: int
    + {abstract} operator int() const: int
}

enum "TypeUnitSymbol" as ENUM_SYMBOLE_UNITAIRE {
    PLUS
    MINUS
    MULT
    DIV
    EQUAL
    AFFECT
    ENDING_PAR
    OPENING_PAR
}
class "UnitSymbol" as CLASS_SYMBOLE_POINT_VIRGULE extends CLASS_SYMBOLE {
    - type: TypeUnitSymbol
}

interface "IActiveSymbol" as INTERFACE_ACTIVE_SYMBOL {
    + computeSymbol(symbol:Symbol)
}

abstract class "SymbolDeclaration" as CLASS_SYMBOLE_DECLARATION extends CLASS_SYMBOLE implements INTERFACE_ACTIVE_SYMBOL {
    + {abstract} execute(dicoVariables)
    + {abstract} {static} analyse()
}
class "SymbolDeclarationVar" as CLASS_SYMBOLE_DECLARATION_VAR extends CLASS_SYMBOLE_DECLARATION {
    - idVariable: string
    + execute(dicoVariables)
    + {static} analyse()
}
class "SymbolDeclarationConst" as CLASS_SYMBOLE_DECLARATION_CONST extends CLASS_SYMBOLE_DECLARATION {
    - variables: map<idVar:string, value:float>
    + execute(dicoVariables)
    + {static} analyse()
}
abstract class "SymbolInstruction" as CLASS_SYMBOLE_INSTRUCTION extends CLASS_SYMBOLE implements INTERFACE_ACTIVE_SYMBOL {
    + {abstract} execute(dicoVariables)
    + {abstract} {static} analyse()
}
class "SymbolInstructionWrite" as CLASS_SYMBOLE_INSTRUCTION_ECRITURE extends CLASS_SYMBOLE_INSTRUCTION {
    + execute(dicoVariables)
    + {static} analyse()
}
class "SymbolInstructionRead" as CLASS_SYMBOLE_INSTRUCTION_VAR_LECTURE extends CLASS_SYMBOLE_INSTRUCTION {
    + execute(dicoVariables)
    + {static} analyse()
}
class "SymbolInstructionAffect" as CLASS_SYMBOLE_INSTRUCTION_VAR_AFFECTATION extends CLASS_SYMBOLE_INSTRUCTION {
    + execute(dicoVariables)
    + {static} analyse()
}

abstract class "SymbolExpression" as CLASS_SYMBOLE_EXPRESSION extends CLASS_SYMBOLE_INSTRUCTION {
    + {abstract} eval(dicoVariables) : float
}

class "SymbolNumber" as CLASS_SYMBOLE_NOMBRE extends CLASS_SYMBOLE_EXPRESSION
class "SymbolVariable" as CLASS_SYMBOLE_VARIABLE extends CLASS_SYMBOLE_EXPRESSION

abstract class "SymbolExpressionBinary" as CLASS_SYMBOLE_EXPRESSION_BINAIRE extends CLASS_SYMBOLE_EXPRESSION {
}

class "SymbolExpressionParenthesis" as CLASS_SYMBOLE_EXPRESSION_PARENTHESE extends CLASS_SYMBOLE_EXPRESSION {
}

class "SymbolExpressionBinaryAdd" as CLASS_SYMBOLE_EXPRESSION_BINAIRE_ADD extends CLASS_SYMBOLE_EXPRESSION_BINAIRE
class "SymbolExpressionBinarySoustract" as CLASS_SYMBOLE_EXPRESSION_BINAIRE_SOUSTRACTION extends CLASS_SYMBOLE_EXPRESSION_BINAIRE
class "SymbolExpressionBinaryMultiplication" as CLASS_SYMBOLE_EXPRESSION_BINAIRE_MULT extends CLASS_SYMBOLE_EXPRESSION_BINAIRE
class "SymbolExpressionBinaryDivision" as CLASS_SYMBOLE_EXPRESSION_BINAIRE_DIV extends CLASS_SYMBOLE_EXPRESSION_BINAIRE

